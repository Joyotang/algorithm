# 链表

----------------------------------------------链表(上)-------------------------------------------------

## 一、什么是链表？
* 1.和数组一样，链表也是一种线性表。
* 2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
* 3.链表中的每一块内存块被称为节点(Node)。节点除了存储数据外，还记录了链上的下一个节点地址，即后继指针(next)。

## 二、为什么使用链表（链表的特征）？
* 插入、删除数据效率**高**：O(1)级别（只需要更改指针指向即可）；
* 随机访问效率**低**：O(n)级别（需要从链头至链尾进行遍历）；
* 和数组相比，内存空间消耗更大（因为每个存储数据的节点都需要额外的空间存储后继指针）。

## 三、常用链表：单链表、循环链表、双向链表

### 1.单链表
* 每个节点只包含一个指针：后继指针；
* 两个特殊的节点：头节点、尾节点 - 用头节点来记录链表的基地址，便于遍历得到整条链表，尾节点的后继指针指向空地址null；
* 性能特点：插入和删除节点的时间复杂度为O(1)，查找的时间复杂度为O(n)。

### 2.循环链表
* 除了尾节点的后继指针指向首节点的地址外，其他均与单链表一致；
* 适用于存储有循环特点的数据，比如约瑟夫问题。

### 3.双向链表
* 每个节点包含两个指针：前驱指针prev（指向前一个节点地址）和后继指针next（指向下一个节点地址）；
* 首节点的前驱指针prev和尾节点的后继指针均指向空地址。
* 性能特点：
    - 和单链表相比，存储相同的数据，需要消耗更多的存储空间；
    - 插入、删除操作比单链表效率更高：O(1)级别；
        以删除为例，删除操作分为2种情况：
        
        * 1.给定数据值删除对应节点；
        * 2.给定节点地址删除节点；

        > * 对于第一种情况，单链表和双向链表都需要从头到尾进行遍历，从而找到对应节点进行删除，时间复杂度为O(n)；
        > * 对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到 `p -> next = q`，时间复杂度为O(n)；而双向链表可以直接找到前驱节点，时间复杂度为O(1)。

    - 对于一个有序链表，双向链表的按值查询效率要比单链表高一些。
        因为我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需查找一半的数据。

### 4.双向循环链表
* 首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。

## 四、选择数组还是链表？

### 时间复杂度（插入、删除、随机访问）
* 数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)；
* 链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂度是O(n)；

### 缺点

#### 数组的缺点
* 若申请的内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M；
* 大小固定，若存储空间不足，需进行扩容，一旦扩容就需要进行数据复制，而这时非常耗时；

#### 链表的缺点
* 内存空间消耗更大，因为需要额外的空间存储指针信息；
* 对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（Garbage Collection 自动垃圾回收）操作。

### 如何选择？
* 数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。
* 如果代码对内存的使用非常苛刻，那数组就更适合。

## 五、应用

### 1.如何分别用链表和数组实现LRU缓冲淘汰策略？

#### 什么是缓存？
缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。

#### 为什么使用缓存？即缓存的特点
缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。

#### 什么是缓存淘汰策略？
指的是当缓存被用满时清理数据的优先顺序。

#### 有哪些缓存淘汰策略？
常见的3种包括：
* 先进先出策略 **FIFO**（First In，First Out）；
* 最少使用策略 **LFU**（Least Frenquently Used）；
* 最近最少使用策略 **LRU**（Least Recently Used）。

#### 链表实现LRU缓存淘汰策略？
* 当访问的数据**存在于**存储的链表中时，遍历并**将其从原来的位置删除**，然后再**插入到链表表头**，时间复杂度为O(n)。
* 如果访问的数据**没有在**缓存链表中，又可以分为两种情况：
    - 如果此时缓存**未满**，则将此节点直接**插入到链表的头部**，时间复杂度为O(1)；
    - 如果此时缓存**已满**，则**将链表尾节点删除**，将新的数据节点**插入到链表的头部**，时间复杂度为O(1)。

#### 数组实现LRU缓存淘汰策略？

* 方式一：首位置保存最新访问数据，末尾位置优先清理
    - 当访问的数据**未存在于**缓存的数组中时，**直接将数据插入数组第一个元素位置**，此时数组中所有元素需要向后移动1个位置，时间复杂度为O(n)；
    - 当访问的数据**存在于**缓存的数组中时，查找到数据并**将其插入数组的第一个位置**，此时亦需移动数组元素，时间复杂度为O(n)；当缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。

* 方式二：首位置优先清理，末尾位置保存最新访问数据
    - 当访问的数据**未存在于**缓存的数组中时，直接将数据**添加进数组作为当前最后一个元素**，时间复杂度为O(1)；
    - 当访问的数据**存在于**缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）

### 2. 如何通过单链表实现“判断某个字符串是否为回文(水仙花)字符串”？（比如 上海自来水来自海上）
* 1）前提：字符串以单个字符的形式存储在单链表中。
* 2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。
* 3）将链表中的字符倒序存储一份在另一个链表中。
* 4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。

## 六、设计思想
时空替换思想：“用空间换时间” 与 “用时间换空间”。

当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。


----------------------------------------------链表(下)-------------------------------------------------

## 如何轻松写出正确的链表代码（6大学习技巧）？

### 一、理解指针或引用的含义
* 含义：将某个变量（对象）赋值给指针（引用），实际上就是将这个变量（对象）的地址赋值给指针（引用）。
* 2.示例：
    - `p->next = q;` 表示p节点的后继指针存储了q节点的内存地址。
    - `p->next = p->next->next;` 表示p节点的后继指针存储了p节点的下下个节点的内存地址。

### 二、警惕指针丢失和内存泄漏（单链表）

* 1.插入节点
    在节点a和节点b之间插入节点x，b是a的下一节点，p指针指向节点a;
    会造成指针丢失和内存泄漏的代码如下：

    ```java
    p->next = x;
    x->next = p->next;
    ```

    显然这会导致x节点的后继指针指向自身。

    正确的写法是2句代码交换顺序，即：

    ```java
    x->next = p->next;
    p->next = x;
    ```

    这里把p看作a就可以了，实际上用JavaScript对象可以如下表达：

    ```javascript
    x.next = b
    a.next = x
    ```

* 2.删除节点
    在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：`p->next = p->next->next;`

## 三、利用“哨兵”简化实现难度
### 1.什么是“哨兵”？

链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。

### 2.未引入“哨兵”的情况
如果在p节点后插入一个节点，只需2行代码即可搞定：

```java
new_node->next = p->next;
p->next = new_node;
```

但，若向空链表中插入一个节点，则代码如下：

```java
if (head == null) {
    head = new_node;
}
```

如果要删除节点p的后继节点，只需1行代码即可搞定：`p->next = p->next->next;`
但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：

```java
if (head->next == null) {
    head = null;
}
```

从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。

### 3.引入“哨兵”的情况
“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。

### 4.“哨兵”还有哪些应用场景？
触及到我的盲区了，暂时想不出来~ 但总结起来，哨兵最大的作用就是**简化边界条件的处理**。

## 四、重点留意边界条件处理
经常用来检查链表是否正确的边界4个边界条件：

* 1.如果链表为空时，代码是否能正常工作？
* 2.如果链表只包含一个节点时，代码是否能正常工作？
* 3.如果链表只包含两个节点时，代码是否能正常工作？
* 4.代码逻辑在处理头尾节点时是否能正常工作？

## 五、举例画图，辅助思考
核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。

## 六、多写多练，没有捷径
5个常见的链表操作：

* 1.单链表反转
* 2.链表中环的检测
* 3.两个有序链表合并
* 4.删除链表倒数第n个节点
* 5.求链表的中间节点
