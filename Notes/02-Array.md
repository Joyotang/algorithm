# 数组

## 什么是数组？
数组（Array）是一种线性表数据结构。用一组连续的储存空间来存储一组相同类型的数据。

### 几个概念：
* 1.线性表(Linear List)：数组、链表、队列、栈等；非线性表：树、二叉树、图等；
* 2.连续的内存空间、相同类型的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作。

## 一、数组如何实现下标随机访问？
引入数组在内存中的分配示意图，得出寻址公式：

```java
a[i]_address = base_address + i * data_type_size
```

### 数组和链表的区别
* 链表适合插入、删除，时间复杂度O(1)，查找的时间复杂度是O(n)；
* 数组的查找操作时间复杂度并不是O(1)，即便是排好的数组，用二分查找，时间复杂度也是O(logn)；数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。

## 二、数组的低效插入与删除

* 1.插入：从最好O(1) 最坏O(n) 平均O(n)
* 2.插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。
* 3.删除：从最好O(1) 最坏O(n) 平均O(n)
* 4.多次删除集中在一起，提高删除效率；
    记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。类似于JVM标记清除垃圾回收算法。

## 三、警惕数组的访问越界问题
用C语言循环越界访问的例子说明访问越界的bug，此例在《C陷阱与缺陷》出现过。

> 如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。

## 四、容器能否完全替代数组
相比于数组，Java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。

### 数组适合的场景：
* 1.Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，可以考虑数组；
* 2.若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组；
* 3.表示多维数组时，数组往往更加直观。
* 4.业务开发容器即可；底层开发，如网络框架，性能优化，选择数组。

## 五、为什么很多编程语言中数组都从0开始编号？
* 从偏移角度理解a[0] 0为偏移量，如果从`1`计数，会多出`K-1`。增加CPU负担。为什么循环要写成`for(int i = 0;i<3;i++)` 而不是`for(int i = 0 ;i<=2;i++)`。第一个直接就可以算出`3-0 = 3` 有三个数据，而后者 `2-0+1` 个数据，对于 CPU 来说多了一次减法指令；

* 也有一定的历史原因，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。

## 六、思考

### JVM标记清除垃圾回收算法原理？

大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。

不足：
* 1.效率问题 - 标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。
* 2.空间问题 - 会产生不连续的内存空间碎片。


### 二维数组的内存寻址公式是怎样的呢？
对于 m * n 的数组，`a[i][j] (i < m,j < n)`的地址为：

```java
address = base_address + ( i * n + j) * type_size
```